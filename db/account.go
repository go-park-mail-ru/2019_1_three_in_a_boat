package db

import (
	"golang.org/x/crypto/bcrypt"
)

// Class representing an account - essential data of a user
// Must not be created or modified directly but im still unsure whether unexported
// fields/types work with JSON, and how hard my life will be if not.
type Account struct {
	Pk       int64  `json:"uid"`
	Username string `json:"username"`
	Email    string `json:"email"`
	Password []byte `json:"-"`
}

// Constructor - takes all the fields excepting Pk, which will be generated by the
// database when Save is called
func NewAccount(username, email, password string) (*Account, error) {
	pwd, err := AccountGeneratePasswordHash(password)
	if err != nil {
		return nil, err
	}

	return &Account{0, username, email, pwd}, nil
}

// Retrieves a single Account from the database, forwards the SQL error, if any
func GetAccount(_db Queryable, uid int64) (*Account, error) {
	account := &Account{}
	err := _db.QueryRow(`SELECT "username", "email", "password"
                       FROM "Account" WHERE uid = $1`, uid).Scan(
		account.Username, account.Email, account.Password)
	if err != nil {
		return nil, err
	} else {
		return account, err
	}
}

// Retrieves a single Account from the database, forwards the SQL error, if any
func (a *Account) Save(_db Queryable) (err error) {
	if a.Pk == 0 {
		err = _db.QueryRow(`INSERT INTO Account ("username", "password", "email")
                      VALUES ($1, $2, $3) RETURNING uid`,
			a.Username, a.Password, a.Email).Scan(&a.Pk)
	} else {
		_, err = _db.Exec(`UPDATE Account 
                       SET "username" = $1, "password"= $2, "email" = $3
                       WHERE "uid" = $4`,
			a.Username, a.Password, a.Email, a.Pk)
	}
	return
}

// Generates a password hash from the given password string, same as in the database
// Must NOT be used for comparing passwords, use AccountComparePasswordToHash instead
func AccountGeneratePasswordHash(password string) ([]byte, error) {
	return bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
}

// Compares a password hash from the given password to a previously hashed value
// Returns false if they aren't equal, true otherwise. Returns an error if the
// hash is invalid
func AccountComparePasswordToHash(password string, hash []byte) (bool, error) {
	err := bcrypt.CompareHashAndPassword(hash, []byte(password))
	if err == bcrypt.ErrMismatchedHashAndPassword || err == nil {
		return err == nil, nil
	} else {
		return false, err
	}
}
