package forms

import (
	"errors"
	"strings"
	"time"

	"github.com/badoux/checkmail"
	"github.com/lib/pq"
	"github.com/nbutton23/zxcvbn-go"

	"github.com/go-park-mail-ru/2019_1_three_in_a_boat/shared/db"
	"github.com/go-park-mail-ru/2019_1_three_in_a_boat/shared/formats"
	"github.com/go-park-mail-ru/2019_1_three_in_a_boat/shared/http-utils"
	"github.com/go-park-mail-ru/2019_1_three_in_a_boat/shared/settings/server"
)

// A struct responsible for validating signup form. Only checks validity of the
// fields, does work with the database, that is done in the corresponding route.
// Null* fields are optional, everything else is required.
type SignupForm struct {
	Username     string        `json:"username"`
	Password     string        `json:"password"`
	Email        string        `json:"email"`
	FirstName    db.NullString `json:"name,omitempty"`
	LastName     db.NullString `json:"lastname,omitempty"`
	BirthDateStr db.NullString `json:"date,omitempty"`
	BirthDate    db.NullTime   `json:"-"`
	ok           bool          `json:"-"`
}

// Returns a report indicating whether the form is valid.
func (f *SignupForm) Validate() *http_utils.Report {
	report := http_utils.NewReport()

	report.Fields["username"] = f.ValidateUsername()
	report.Fields["password"] = f.ValidatePassword()
	report.Fields["email"] = f.ValidateEmail()
	report.Fields["name"] = f.ValidateFirstName()
	report.Fields["lastname"] = f.ValidateLastName()
	report.Fields["date"] = f.ValidateBirthDate()

	// optional fields return OK if they're empty - error only if the data is
	// there, but it's invalid
	report.Ok = report.Fields["username"].Ok && report.Fields["password"].Ok &&
		report.Fields["email"].Ok && report.Fields["name"].Ok &&
		report.Fields["lastname"].Ok && report.Fields["date"].Ok
	f.ok = report.Ok

	return report
}

// If the form is valid, returns a db.User object, which can be directly saved.
// Despite the fact that the validation already succeeded, the DB might return
// an error if DB constraints (namely, unique username and email) are violated.
// See CheckUserDbConstraints docs to catch this case.
func (f *SignupForm) MakeUser() (*db.User, error) {
	if !f.ok {
		return nil, http_utils.ErrFormInvalid
	}
	a, err := db.NewAccount(f.Username, f.Email, f.Password)
	if err != nil {
		return nil, err
	}

	p, err := db.NewProfile(0, f.FirstName, f.LastName,
		db.NullInt64{0, false}, db.NullString{"", false},
		db.NullString{"", false}, f.BirthDate)
	if err != nil {
		return nil, err
	}

	u, err := db.NewUser(a, p)
	if err != nil {
		return nil, err
	}

	return u, nil
}

// Validates username: trims it and checks 3 <= len(f.Username) <= 32
func (f *SignupForm) ValidateUsername() (r http_utils.FieldReport) {
	f.Username = strings.TrimSpace(f.Username)
	return CheckLength(f.Username, 3, 32)
}

// Validates username: checks 8 <= len(f.Password) <= 128. Also checks strength
// and if it's weaker than MinPasswordStrength (0..4), returns an error
// indicating ErrPasswordTooWeak{strength}. Note that if MinPasswordStrength > 4
// the function will panic on a very strong password.
func (f *SignupForm) ValidatePassword() (r http_utils.FieldReport) {
	if len([]byte(f.Password)) > 128 { // What if they're trying to overload our hash?
		r.Errors = []string{formats.ErrFieldTooLong}
	} else if len([]byte(f.Password)) < 8 {
		r.Errors = []string{formats.ErrFieldTooShort}
	}

	strength := zxcvbn.PasswordStrength(f.Password, []string{f.Username, f.Email,
		f.FirstName.String, f.LastName.String})

	if strength.Score < server_settings.MinPasswordStrength {
		r.Errors = append(r.Errors, formats.ErrPasswordTooWeak[strength.Score])
	}

	r.Ok = len(r.Errors) == 0
	return
}

// Validates email: trims and validates format; if EmailExistsCheck is true,
// also checks that the email is real. This can be rather long (up to 1 second)
// since it requires an answer from the SMTP server.
func (f *SignupForm) ValidateEmail() (r http_utils.FieldReport) {
	f.Email = strings.TrimSpace(f.Email)
	if err := checkmail.ValidateFormat(f.Email); err != nil {
		r.Errors = []string{formats.ErrInvalidEmail}
		return
	}

	//noinspection GoBoolExpressions
	if !server_settings.EmailExistsCheck {
		r.Ok = true
		return
	}

	if err := checkmail.ValidateHost(f.Email); err != nil {
		r.Errors = []string{formats.ErrEmailDomainDoesNotExist}
	} else {
		err := checkmail.ValidateHost(f.Email)
		if _, valid := err.(checkmail.SmtpError); valid && err != nil {
			r.Errors = []string{formats.ErrEmailDoesNotExist}
		} else {
			r.Ok = true
		}
	}

	return
}

// Validates birth date: sets f.BirthDate to parsed f.BirthDateStr, or sets the
// former to null if the latter is 0-0-0 or null. Empty string returns an
// erroneous report.
func (f *SignupForm) ValidateBirthDate() (r http_utils.FieldReport) {
	// BirthDateStr is generated by JS so no point in trimming
	var err error
	if f.BirthDateStr.String == "0-0-0" || !f.BirthDateStr.Valid {
		// f.BirthDate stays Null
		return http_utils.FieldReport{true, nil}
	}

	f.BirthDate.Time, err = time.Parse(formats.DateFormat, f.BirthDateStr.String)
	if err != nil {
		r.Errors = append(r.Errors, formats.ErrInvalidDate)
	} else if f.BirthDate.Time.Year() < 1900 || time.Now().Before(f.BirthDate.Time) {
		r.Errors = append(r.Errors, formats.ErrDateOutOfRange)
	} else {
		r.Ok = true
		f.BirthDate.Valid = true
	}

	return
}

// Validate first name: trims it and checks len(f.FirstName) < 32 Lower boundary
// is 0 in case of hieroglyphs or something.
func (f *SignupForm) ValidateFirstName() (r http_utils.FieldReport) {
	f.FirstName.String = strings.TrimSpace(f.FirstName.String)
	return CheckLengthOptional(&f.LastName, 1, 32)
}

// Validates last name the same way as ValidateFirstName validates first name
func (f *SignupForm) ValidateLastName() (r http_utils.FieldReport) {
	f.LastName.String = strings.TrimSpace(f.LastName.String)
	return CheckLengthOptional(&f.LastName, 1, 32)
}

// Takes an error returned by the database. If that error indicates a constraint
// violation on account_username_key or account_email_key, returns an erroneous
// report AND an error. If the error returned by the database was caused by
// something else returns nil, err. If the err is nil, returns nil, nil.
func CheckUserDbConstraints(err error) (*http_utils.Report, error) {
	if err != nil {
		report := http_utils.NewReport("username", "password", "email",
			"name", "lastname", "date")
		if pqErr, ok := err.(*pq.Error); ok && pqErr.Constraint != "" {
			fieldReport :=
				http_utils.FieldReport{false, []string{formats.ErrUniqueViolation}}

			if pqErr.Constraint == "account_username_key" {
				report.Fields["username"] = fieldReport
			} else if pqErr.Constraint == "account_email_key" {
				report.Fields["email"] = fieldReport
			} // else shouldn't ever be possible
			return report, errors.New(formats.ErrUniqueViolation)
		}
		return nil, err
	}

	return nil, nil
}
