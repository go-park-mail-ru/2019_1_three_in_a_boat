package db

import (
	"golang.org/x/crypto/bcrypt"
)

// Struct representing an account - essential data of a user. Must not be created
// or modified directly. Empty initialization, however, as a placeholder for a
// scan is ok.
type Account struct {
	Pk       int64  `json:"uid"`
	Username string `json:"username"`
	Email    string `json:"email"`
	Password []byte `json:"-"`
}

// Constructor - takes all the fields excepting Pk, which will be generated by
// the database when Save is called. The password is going to be encrypted
// within the method, so no need to encrypt it outside of it.
func NewAccount(username, email, password string) (*Account, error) {
	pwd, err := AccountGeneratePasswordHash(password)
	if err != nil {
		return nil, err
	}

	return &Account{0, username, email, pwd}, nil
}

// Retrieves a single Account from the database, forwards the SQL error, if any
func GetAccount(_db Queryable, uid int64) (*Account, error) {
	account := &Account{}
	err := _db.QueryRow(`SELECT "username", "email", "password"
                       FROM "Account" WHERE uid = $1`, uid).Scan(
		account.Username, account.Email, account.Password)
	if err != nil {
		return nil, err
	} else {
		return account, err
	}
}

// Saves an Account in the database, forwards the SQL error, if any. Can be
// used for both updating and inserting. The operation is determined based on
// Pk: 0 -> INSERT, non-0 - update. Return error can be examined via type
// assertion to the underlying driver's error type
func (a *Account) Save(_db Queryable) (err error) {
	if a.Pk == 0 {
		err = _db.QueryRow(`INSERT INTO Account ("username", "password", "email")
                      VALUES ($1, $2, $3) RETURNING uid`,
			a.Username, a.Password, a.Email).Scan(&a.Pk)
	} else {
		_, err = _db.Exec(`UPDATE Account 
                       SET "username" = $1, "password"= $2, "email" = $3
                       WHERE "uid" = $4`,
			a.Username, a.Password, a.Email, a.Pk)
	}
	return
}

// Encrypts a password, same way as it's encrypted when added to the database.
// Must not be used for comparing passwords, use AccountComparePasswordToHash
// instead
func AccountGeneratePasswordHash(password string) ([]byte, error) {
	return bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
}

// Compares a password hash from the given password to a previously hashed value
// Returns true if they are equal, false otherwise. Returns an error if the
// hash is invalid or can not be read.
func AccountComparePasswordToHash(password string, hash []byte) (bool, error) {
	err := bcrypt.CompareHashAndPassword(hash, []byte(password))
	if err == bcrypt.ErrMismatchedHashAndPassword || err == nil {
		return err == nil, nil
	} else {
		return false, err
	}
}
